<hr>

<h3>Find Majority Item (Boyer-Moore Voting Algorithm)</h3>
<p>Input/Output Example</p>
<pre>
    Input: nums = [2,2,1,1,1,2,2]
    Output: 2
</pre>

<p>We can do it in nlogn complexity.</p>
<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
}
</textarea>
</code></pre>
<hr>
<p>We can do it in O(n). If we had some way of counting instances of the majority element as +1
    and instances of any other element as −1, summing them would make it
    obvious that the majority element is indeed the majority element.</p>
<pre><code class="language-java">
<textarea hidden>
public int majorityElement(int[] nums) {
    int count = 0;
    Integer candidate = null;

    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }

    return candidate;
}
</textarea>
</code></pre>

<hr>

<h3>Majority Element II</h3>
<a href="https://leetcode.com/problems/majority-element-ii">Leetcode Link</a>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>

<p>Approach: Know that</p>
<ul>
    <li>There can be at most one majority element which is more than ⌊n/2⌋ times.</li>
    <li>There can be at most two majority elements which are more than ⌊n/3⌋ times.</li>
    <li>There can be at most three majority elements which are more than ⌊n/4⌋ times.</li>
</ul>


<pre><code class="language-java">
<textarea hidden>
class Solution {
    public List < Integer > majorityElement(int[] nums) {

        int count1 = 0;
        int count2 = 0;

        Integer candidate1 = null;
        Integer candidate2 = null;

        for (int n: nums) {
            if (candidate1 != null && candidate1 == n) {
                count1++;
            } else if (candidate2 != null && candidate2 == n) {
                count2++;
            } else if (count1 == 0) {
                candidate1 = n;
                count1++;
            } else if (count2 == 0) {
                candidate2 = n;
                count2++;
            } else {
                count1--;
                count2--;
            }
        }

        List result = new ArrayList <> ();

        count1 = 0;
        count2 = 0;

        for (int n: nums) {
            if (candidate1 != null && n == candidate1) count1++;
            if (candidate2 != null && n == candidate2) count2++;
        }

        int n = nums.length;
        if (count1 > n/3) result.add(candidate1);
        if (count2 > n/3) result.add(candidate2);

        return result;
    }
}
</textarea>
</code></pre>