<h3>Example: Counting Total Covered Length of Intervals</h3>
<p>This Java class addresses the problem of efficiently calculating the total length covered by a stream of added intervals, ensuring that overlaps are only counted once. The approach uses a <b>TreeMap</b> to store non-overlapping intervals, mapping the start (left) of an interval to its end (right). When a new interval `[l, r]` is added, the code iteratively checks for and merges all existing intervals that overlap with it using a <b>greedy merge strategy</b>. The total count is updated by subtracting the length of the removed intervals and adding the length of the newly merged, extended interval.</p>

<pre><code class="language-java">
<textarea hidden>
class CountIntervals {

    TreeMap<Integer,Integer> map;
    int count;

    public CountIntervals() {
        map = new TreeMap<>();
        count = 0;
    }

    public void add(int left, int right) {

        int l = left;
        int r = right;

        int overlappingKey = findOverlappingKey(l, r);

        while(overlappingKey >= 0) {

            int overlappingValue = map.get(overlappingKey);

            count -= overlappingValue - overlappingKey + 1;
            map.remove(overlappingKey);

            l = Math.min(l, overlappingKey);
            r = Math.max(r, overlappingValue);

            overlappingKey = findOverlappingKey(l, r);
        }

        map.put(l, r);
        count += r - l + 1;
    }

    public int count() {
        return count;
    }

    public int findOverlappingKey(int l, int r) {
        Integer nearestKey = map.floorKey(r);
        if (nearestKey != null) {
            if (map.get(nearestKey) >= l)
                return nearestKey;
        }
        return -1;
    }
}
</textarea>
</code></pre>

<p>Items to note:</p>

<ol style="list-style-type: lower-alpha;">
<li>Why do we need a treemap? Ans: To keep sorted intervals. floorKey takes O(logn).</li>
<li>How to detect overlap between intervals? Ans: map.get(map.floorKey(r)) >= l</li>
<li>Avoid multiple calls to floorKey by using findOverlappingKey instead of hasOverlap and getOverlappingKey.</li>
    <li>Treemap uses Red Black tree. it is a self-balancing Binary Search Tree (BST), which is crucial for guaranteeing
        efficient performance regardless of the order in which data is inserted. A Red-Black Tree automatically adjusts
        its structure (through recoloring and rotations) after every insertion and deletion to ensure the tree remains
        approximately balanced. For all major operations like get(), put(), remove(), and navigation methods (floorKey(), ceilingKey(), etc.), the worst-case time complexity is guaranteed to be $O(\log n)$. This consistent, logarithmic performance is what makes TreeMap reliable, even with millions of entries.</li>
</ol>
