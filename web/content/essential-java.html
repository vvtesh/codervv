<hr>

<h3>Essential Java Snippets</h3>

<p>
    Some essential Java sorting patterns to revise before coding.
</p>

<pre><code class="language-java">
<textarea hidden>

    //sort an array
    Arrays.sort(numbers);
    Arrays.sort(numbers, Collections.reverseOrder());
    //sort in asc/descending order with collections
    Collections.sort(numbers); // Sorts in ascending order
    Collections.sort(names, Collections.reverseOrder());

    ArrayList<int[]> edges = new ArrayList<>();
    //Sort an arraylist or a collection by some attribute
    //lambda
    Collections.sort(edges, (a,b) -> a[2] - b[2]);
    Collections.sort(people, (p1, p2) -> Integer.compare(p1.age, p2.age));
    //comparator
    Collections.sort(people, Comparator.comparing(p -> p.name));
    //custom comparator
    Collections.sort(people, new LexicographicComparator());
    class LexicographicComparator implements Comparator<Person> {
    @Override
    public int compare(Person a, Person b) {
        return a.name.compareToIgnoreCase(b.name);
    }

</textarea>
</code></pre>

<hr>

<p>
    Essential operations on Arrays
</p>

<pre><code class="language-java">
<textarea hidden>
    Collections.reverse(someArray);
    Arrays.fill(row, Integer.MAX_VALUE);

    //Insert position after binary search
    int idx = Collections.binarySearch(sub, num);
    int j = (idx >= 0 ? idx : ~idx);
</textarea>
</code></pre>

<hr>

<p>
    Essential operations on Heaps
</p>

<pre><code class="language-java">
<textarea hidden>
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
    heap.add(7451);
    System.out.println(heap.remove());
    Heap.peek();
    PriorityQueue < int[] > queue = new PriorityQueue < > ((a, b) -> a[2] - b[2]);
    queue.offer(new int[]{start[0],start[1],0});
    int[] s = queue.poll();

</textarea>
</code></pre>

<hr>

<p>
    Essential operations on Optional
</p>

<pre><code class="language-java">
<textarea hidden>
    Optional.of("Alice");
    Optional.empty()
    user1.ifPresent(name -> System.out.println("User found: " + name));
    String userName = user2.orElse("Guest");
    String requiredUser = user3.orElseThrow(() -> new IllegalArgumentException("User not found!"));
</textarea>
</code></pre>

<hr>

<p>
    Essential operations on Pair
</p>

<pre><code class="language-java">
<textarea hidden>
    Pair<Integer, Integer> p = queue.poll();
    int row = p.getKey();
    int col = p.getValue();
    //typical operations on pair
	visited.add(new Pair(row, col));
    !visited.contains(new Pair(newRow, newCol))
</textarea>
</code></pre>

<hr>

<p>
    Essential queue operations
</p>

<pre><code class="language-java">
<textarea hidden>
    //Common represenations
    Queue<String> queue = new LinkedList<>(Arrays.asList(""))
    queue.isEmpty()
    queue.poll()
    queue.offer(curString + ")")

    Queue<Integer> queue = new LinkedList<>()
    Queue<Pair<Integer, Integer>> queue = new ArrayDeque()
    PriorityQueue < int[] > queue = new PriorityQueue < > ((a, b) -> a[2] - b[2])
    PriorityQueue<Integer> allocator = new PriorityQueue<Integer>(n)
    allocator.add(intervals[0][1])

</textarea>
</code></pre>

<hr>

<p>
    Essential graph operations
</p>

<pre><code class="language-java">
<textarea hidden>
    //Common represenations
    List<List> //adjacency list [[1,2],[2,3],[4,5]]
    List<int[]> //edges in list [{1,2},{2,3},{4,5}]
    Int[][] //edges array {{1,2},{2,3},{4,5}}

    Map<String, List<String>> graph = new HashMap<>();
    //synonyms = [["happy","joy"],["sad","sorrow"],["joy","cheerful"]]
    private void buildGraph(List<List<String>> synonyms) {
        for(List<String> list : synonyms) {
            graph.putIfAbsent(list.get(0), new ArrayList<>());
            graph.putIfAbsent(list.get(1), new ArrayList<>());
            graph.get(list.get(0)).add(list.get(1));
            graph.get(list.get(1)).add(list.get(0));
        }
    }

</textarea>
</code></pre>