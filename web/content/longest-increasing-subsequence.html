<h3>Longest Increasing Subsequence (LIS)</h3>
<a href="https://leetcode.com/problems/longest-increasing-subsequence/description/">Visit Leetcode: Longest Increasing Subsequence</a>
<p/>
<p>Input/Output Example</p>
<pre>
    Input: nums = [10,9,2,5,3,7,101,18]
    Output: 4
    Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</pre>
<p>Key Idea</p>
<pre>
    1. Let dp[i] represent the length of the LIS ending at index i.
    2. So, if nums[i+1]>nums[i], then dp[i+1] = dp[i] + 1.
    3. More so, dp[i] = max(dp[j] + 1) for all j where nums[j] < nums[i] and j < i.
    4. We can initialize dp elements to 1.
</pre>
<p>Solution</p>
<pre>
<code class="language-java">
<textarea hidden>
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        int longest = 0;
        for (int c: dp) {
            longest = Math.max(longest, c);
        }

        return longest;
    }
}
</textarea>
</code>
</pre>
<hr>
<p>A tricky way</p>
<pre>
    1. Consider the example nums = [8, 1, 6, 2, 3, 10].
    2. Start with [].
    3. Add 8. So, [8].
    4. 1 < 8. So, better to have [1] rather than [8]. We have better chance of finding a longer seq.
    5. Then, [1,6].
    6. Now, [1,2]. Then, [1,2,3].
    7. Finally, [1,2,3,10].
</pre>
<p>This algorithm does not always generate a valid subsequence of the input, but the length of the subsequence will always equal the length of the LIS. For example, with the input [3, 4, 5, 1], at the end we will have sub = [1, 4, 5], which isn't a subsequence, but the length is still correct.</p>
<p>Solution</p>
<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int lengthOfLIS(int[] nums) {
        ArrayList<Integer> sub = new ArrayList<>();
        sub.add(nums[0]);

        for (int i = 1; i < nums.length; i++) {
            int num = nums[i];
            if (num > sub.get(sub.size() - 1)) {
                sub.add(num);
            } else {
                int idx = Collections.binarySearch(sub, num);
                int j = (idx >= 0 ? idx : ~idx);
                sub.set(j, num);
            }
        }

        return sub.size();
    }
}
</textarea>
</code></pre>