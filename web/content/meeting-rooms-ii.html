<h3>Example: Minimum Meeting Rooms Solution</h3>
<p>This code solves the problem of finding the <b>minimum number of conference rooms</b> required to accommodate a given set of meeting time intervals. The approach first sorts the meetings by their start times to process them chronologically. It then uses a <b>Min-Heap (PriorityQueue)</b> to keep track of the earliest ending time among all currently occupied rooms. If a new meeting's start time is greater than or equal to the earliest room end time (`allocator.peek()`), that room is freed up (`allocator.poll()`) and reused for the new meeting; otherwise, a new room is needed. The final size of the Min-Heap is the minimum number of rooms needed.</p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        int n = intervals.length;
        if (n == 0) return 0;
        PriorityQueue<Integer> allocator = new PriorityQueue<Integer>();
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        allocator.add(intervals[0][1]);
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= allocator.peek()) {
                allocator.poll();
            }
            allocator.add(intervals[i][1]);
        }
        return allocator.size();
    }
}
</textarea>
</code></pre>

<p>Notes</p>
<pre>
    1. Sort the intervals by start time.
    2. Process intervals one by one.
        2.a) When processing each, for all the intervals so far added, get the earliest end time.
            (priority queue helps here.)
        2.b) If the interval to be added starts after the prev smallest end time,
            remove the prev smallest end time from queue.
    3. Return the priority queue size.
</pre>