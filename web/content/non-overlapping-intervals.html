

<h3></h3>

<a href="https://leetcode.com/problems/non-overlapping-intervals/editorial/">Non-Overlapping Intervals</a>
<p>
Finding the minimum number of intervals to remove is equivalent to finding the maximum number of non-overlapping intervals.
</p>

<pre>
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
</pre>

<p>
    This is the famous interval scheduling problem.

    Let's start by considering the intervals according to their end times. Consider the two intervals with the earliest end times. Let's say the earlier end time is x and the later one is y. We have x < y. To avoid overlap, We should always greedily choose the interval with an earlier end time x.

    In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm, which has a space complexity of O(logn). In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of O(n).

    Note: Arrays.sort(intervals, Comparator.comparingInt(a -> a[1])); Same as "Arrays.sort(intervals, (a,b)->a[1]-b[1]);".

    List of interval problems: https://leetcode.com/problem-list/oqv95d22/

</p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));
        int ans = 0;
        int k = Integer.MIN_VALUE; //end time of prev interval

        for (int i = 0; i < intervals.length; i++) {
            int x = intervals[i][0];
            int y = intervals[i][1];

            if (x >= k) {
                k = y;
            } else {
                ans++;
            }
        }

        return ans;
    }
}
</textarea>
</code></pre>

<hr>

<p> </p>

<pre><code class="language-java">
<textarea hidden>

</textarea>
</code></pre>