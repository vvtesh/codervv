

<h3></h3>

<a href="https://leetcode.com/problems/non-overlapping-intervals/editorial/">Non-Overlapping Intervals</a>
<p>
Finding the minimum number of intervals to remove is equivalent to finding the maximum number of non-overlapping intervals.
</p>

<pre>
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
</pre>

<p>
    This is the famous interval scheduling problem.

    Let's start by considering the intervals according to their end times.

    Consider the two intervals with the earliest end times. Let's say the earlier end time is x and the later one is y. We have x < y. To avoid overlap, We should always greedily choose the interval with an earlier end time x.

</p>
<p>Note: Arrays.sort(intervals, Comparator.comparingInt(a -> a[1])); Same as "Arrays.sort(intervals, (a,b)->a[1]-b[1]);".
</p>
<p>Note on space complexity: In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm, which has a space complexity of O(logn). In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of O(n).
</p>
<p>List of interval problems: https://leetcode.com/problem-list/oqv95d22/</p>
<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {

        //This is the key step.
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));

        int ans = 0;
        int prevEnd = Integer.MIN_VALUE;

        for (int i = 0; i < intervals.length; i++) {
            int start = intervals[i][0];
            int end = intervals[i][1];

            if (start >= prevEnd) {
                prevEnd = end;
            } else {
                ans++;
            }
        }

        return ans;
    }
}
</textarea>
</code></pre>

<hr>

<p> </p>

<pre><code class="language-java">
<textarea hidden>

</textarea>
</code></pre>