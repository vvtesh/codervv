

<h3>Basics of Priority Queue</h3>
<p>Notes: Minheap by default. [30,5,10] -> [5,10,30] where 5 is the first element to pop. </p>

<pre><code class="language-java">
<textarea hidden>
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;

public class PriorityQueueExample {

    public static void main(String[] args) {

        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        //same as
        //PriorityQueue<Integer> minHeap = new PriorityQueue<>((a,b)->a-b);

        // Adding elements
        minHeap.offer(30);
        minHeap.offer(10);
        minHeap.offer(20);
        minHeap.offer(5);

        // Note: Output is not guaranteed to be sorted
        System.out.println("Initial Min-Heap: " + minHeap);

        // Retrieving and removing elements (The smallest element comes out first)
        System.out.println("Polling elements from Min-Heap:");
        while (!minHeap.isEmpty()) {
            System.out.println("Polled: " + minHeap.poll() + " | Queue state: " + minHeap);
        }

        System.out.println("\n-----------------------------------\n");

        System.out.println("--- 2. Max-Heap (Custom Ordering) ---");

        // Option A: Using Collections.reverseOrder()
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        //same as
        //PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b)->b-a);

        // Adding elements
        maxHeap.offer(15);
        maxHeap.offer(45);
        maxHeap.offer(25);
        maxHeap.offer(55);

        System.out.println("Initial Max-Heap: " + maxHeap);

        // Retrieving and removing elements (The largest element comes out first)
        System.out.println("Polling elements from Max-Heap:");
        while (!maxHeap.isEmpty()) {
            System.out.println("Polled: " + maxHeap.poll() + " | Queue state: " + maxHeap);
        }

        System.out.println("\n-----------------------------------\n");
    }
}
</textarea>
</code></pre>

<pre>Output

--- 1. Min-Heap (Natural Ordering) ---
Initial Min-Heap: [5, 10, 20, 30]
Polling elements from Min-Heap:
Polled: 5 | Queue state: [10, 30, 20]
Polled: 10 | Queue state: [20, 30]
Polled: 20 | Queue state: [30]
Polled: 30 | Queue state: []

-----------------------------------

--- 2. Max-Heap (Custom Ordering) ---
Initial Max-Heap: [55, 45, 25, 15]
Polling elements from Max-Heap:
Polled: 55 | Queue state: [45, 15, 25]
Polled: 45 | Queue state: [25, 15]
Polled: 25 | Queue state: [15]
Polled: 15 | Queue state: []

-----------------------------------
</pre>
<hr>

<pre><code class="language-java">
<textarea hidden>
// K largest - use min heap of size k. Example: [5,6] from [1,2,3,4,5,6]
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
for (int num : nums) {
    minHeap.add(num);
    if (minHeap.size() > k) {
        minHeap.poll();  // Remove smallest
    }
}

// K smallest - use max heap of size k. Example: [2,1] from [1,2,3,4,5,6]
PriorityQueue<Integer> maxHeap =
       new PriorityQueue<>(Collections.reverseOrder());
for (int num : nums) {
    maxHeap.add(num);
    if (maxHeap.size() > k) {
        maxHeap.poll();  // Remove largest
    }
}
</textarea>
</code></pre>