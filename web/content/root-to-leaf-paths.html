

<p>Given the root of a binary tree, return all root-to-leaf paths in any order.</p>
<p>Key Points:</p>
<ul>
    <li>What will be the base condition?</li>
    <li>What will you do when you backtrack?</li>
    <li>What will you keep as parameters?</li>
</ul>

<h3>Top down - Start with root</h3>
<p>Simple. But, cannot memoize. Time complexity: O(nlogn). In each node, we copy path proportional to height of the tree. Space complexity: O(n) due to stack space need.</p>
<pre><code class="language-java">
<textarea hidden>
    class Solution {
        public void construct_paths(TreeNode root, String path, LinkedList<String> paths) {

            if (root == null) return;
            path += Integer.toString(root.val);
            if ((root.left == null) && (root.right == null)) {
                paths.add(path);
                System.out.println(path);
            } else {
                path += "->";
                System.out.println(path);
                construct_paths(root.left, path, paths);
                construct_paths(root.right, path, paths);
            }
        }

        public List<String> binaryTreePaths(TreeNode root) {
            LinkedList<String> paths = new LinkedList();
            construct_paths(root, "", paths);
            return paths;
        }
    }
</textarea>
</code></pre>

<pre>
    Output:
        1->
        1->2->
        1->2->5
        1->3
</pre>

<hr>

<h3>Bottom Up - Start with leaf. Build up the result till the root.</h3>
<p>Code is longer. But, can be memoized. Starting with leaf node, we compute the List&lt;List&lt;Integer&gt&gt; for every node till we reach the root.</p>
<pre><code class="language-java">
<textarea hidden>
    class Solution {

        Map<TreeNode, List<List<Integer>>> memo = new HashMap<>();

        public List<String> binaryTreePaths(TreeNode root) {

            List<String> ans = new ArrayList<>();
            if (root == null) return ans;
            List<List<Integer>> nodes = solve(root);
            List<String> paths = process(nodes);
            return paths;
        }

        List<String> process(List<List<Integer>> nodes) {
            List<String> result = new ArrayList<>();
            for(List<Integer> nodesl: nodes) {
                Collections.reverse(nodesl);
                StringBuilder sb = new StringBuilder();
                for(int i=0; i<nodesl.size(); i++) {
                    sb.append(nodesl.get(i));
                    if (i < nodesl.size()-1) sb.append("->");
                }
                result.add(sb.toString());
            }
            return result;
        }

        List<List<Integer>> solve(TreeNode node) {

            if (memo.containsKey(node)) return memo.get(node);

            if (node.left == null && node.right == null) {
                List<Integer> list = new ArrayList<>();
                list.add(node.val);
                List<List<Integer>> result = new ArrayList<>();
                result.add(list);
                return result;
            }

            List<List<Integer>> result = new ArrayList<>();
            if (node.left != null) result = solve(node.left);
            if (node.right != null) result.addAll(solve(node.right));

            for(List<Integer> list: result) {
                list.add(node.val);
            }
            memo.put(node, result);

            return result;
        }
    }
</textarea>
</code></pre>

<hr>

<h3>Backtracking approach - Fastest (1ms)</h3>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        List<Integer> curr = new ArrayList<>();
        solve(root, curr, result);
        return result;
    }

    void solve(TreeNode root, List<Integer> curr, List<String> result) {
        if (root.left==null && root.right==null) {
            curr.add(root.val);
            result.add(process(curr));
            return;
        }

        curr.add(root.val);
        if (root.left != null) {
            solve(root.left, curr, result);
            curr.removeLast();
        }
        if (root.right != null) {
            solve(root.right, curr, result);
            curr.removeLast();
        }
    }

    String process(List<Integer> curr) {
        StringBuilder sb = new StringBuilder();
        int n = curr.size();
        for(int i=0; i<n; i++) {
            sb.append(curr.get(i));
            if (i < n-1) sb.append("->");
        }
        return sb.toString();
    }
}
</textarea>
</code></pre>

<table width="100%"><tr><td align="right"><a href="https://leetcode.com/problems/binary-tree-paths/"><img width="25px" src="content/images/leetcode.png"</a></td></tr></table>

<hr>
