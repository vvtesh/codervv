<pre>
    Input: s = "()[]{}"
    Output: true
</pre>
<pre><code class="language-java">
<textarea hidden>
    public boolean isValid(String s) {

        Map<Character, Character> map = Map.of('(', ')', '[',']','{','}');

        Stack stack = new Stack();
        for (int i = 0; i < s.length(); i++) {

            char c = s.charAt(i);

            if (map.containsKey(c)) {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                char top = (char) stack.peek();
                if (c == map.get(top)) {
                    stack.pop();
                } else {
                    return false;
                }
            }

        }
        if (stack.isEmpty()) {
            return true;
        }
        return false;

    }
</textarea>
</code></pre>

<table width="100%"><tr><td align="right"><a href="https://leetcode.com/problems/valid-parentheses/"><img width="25px" src="content/images/leetcode.png"></a></td></tr></table>

<hr>
<h3>Remove All Adjacent Duplicates In String</h3>
<p>Given s = "abbaca", you can first remove the "bb" to get "aaca". Next, you can remove the "aa" to get "ca". </p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder stack = new StringBuilder();
        for (char c: s.toCharArray()) {
            if (stack.length() > 0 && stack.charAt(stack.length() - 1) == c) {
                stack.deleteCharAt(stack.length() - 1);
            } else {
                stack.append(c);
            }
        }

        return stack.toString();
    }
}
</textarea>
</code></pre>
<table width="100%"><tr><td align="right"><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/"><img width="25px" src="content/images/leetcode.png"></a></td></tr></table>

<hr>

<h3>Daily Temparatures</h3>
<p>Note that replacing ArrayDeque with stack slows the program from 24ms to 80ms. Stack is built over Vector which is a synchronized data structure.</p>
<pre>
    Return the number of days you have to wait after the ith day to get a warmer temperature.
    Input: temperatures = [73,74,75,71,69,72,76,73]
    Output: [1,1,4,2,1,1,0,0]
</pre>
<pre><code class="language-java">
<textarea hidden>
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];
        //Use arraydeque instead of stack. Plain array is even faster.
        Deque<Integer> stack = new ArrayDeque<>();

        for (int currDay = 0; currDay < n; currDay++) {
            int currentTemp = temperatures[currDay];
            while (!stack.isEmpty() && temperatures[stack.peek()] < currentTemp) {
                int prevDay = stack.pop();
                answer[prevDay] = currDay - prevDay;
            }
            stack.push(currDay);
        }

        return answer;
    }
</textarea>
</code></pre>
<table width="100%"><tr><td align="right"><a href="https://leetcode.com/problems/daily-temperatures/description/"><img width="25px" src="content/images/leetcode.png"></a></td></tr></table>

<hr>

<a href="https://leetcode.com/problems/asteroid-collision/">Asteroid Collision</a>
<p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>
<pre>
    Input: asteroids = [5,10,-5]
    Output: [5,10]
    Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
</pre>
<pre><code class="language-java">
    <textarea hidden>
        public int[] asteroidCollision(int[] asteroids) {
            Stack<Integer> st = new Stack<Integer>();

            for (int asteroid : asteroids) {
                boolean flag = true;
                while (!st.isEmpty() && (st.peek() > 0 && asteroid < 0)) {

                    if (Math.abs(st.peek()) < Math.abs(asteroid)) {
                        st.pop();
                        continue;
                    } else if (Math.abs(st.peek()) == Math.abs(asteroid)) {
                        st.pop();
                    }

                    flag = false;
                    break;
                }

                if (flag) {
                    st.push(asteroid);
                }
            }

            int[] remainingAsteroids = new int[st.size()];
            for (int i = remainingAsteroids.length - 1; i >= 0; i--) {
                remainingAsteroids[i] = st.peek();
                st.pop();
            }

            return remainingAsteroids;
        }
    </textarea>
</code></pre>
<br>
<hr>