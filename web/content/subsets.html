

<h3>Subsets</h3>
<a href="https://leetcode.com/problems/subsets/description/">Leetcode: Subsets</a>
<p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p>
<pre>
    Example Input/Output
    Input: nums = [1,2,3]
    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</pre>

<pre><code class="language-java">
<textarea hidden>
class Solution {

    List<List<Integer>> results = new ArrayList<>();
    int[] nums;

    public List<List<Integer>> subsets(int[] nums) {
        this.nums = nums;
        solve(0, new ArrayList<>());
        return results;
    }

    public void solve(int idx, List<Integer> curr) {

        System.out.println(curr);
        results.add(new ArrayList<>(curr));

        for(int i=idx; i<nums.length; i++) {
            curr.add(nums[i]);
            solve(i+1, curr);
            curr.remove(curr.size()-1);
        }
    }
}
</textarea>
</code></pre>

<pre>
Output:
    []
    [1]
    [1, 2]
    [1, 2, 3]
    [1, 3]
    [2]
    [2, 3]
    [3]
</pre>

<hr>

Bit mask trick.

<pre><code class="language-java">
<textarea hidden>
    class Solution {

        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList();
            int n = nums.length;

            for (int i = (int) Math.pow(2, n); i < (int) Math.pow(2, n + 1); ++i) {

                String bitmask = Integer.toBinaryString(i).substring(1);

                List<Integer> curr = new ArrayList();
                for (int j = 0; j < n; ++j) {
                    if (bitmask.charAt(j) == '1') curr.add(nums[j]);
                }
                output.add(curr);
            }
            return output;
        }
}
</textarea>
</code></pre>


<pre><code class="language-java">
<textarea hidden>
    class Solution {

        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList();
            int n = nums.length;

            for (int i = 0; i < (int) Math.pow(2, n); ++i) {
                String bitmask = Integer.toBinaryString(i);
                int bitmaskLen = bitmask.length();

                List<Integer> curr = new ArrayList();
                int currBit = 0;
                while (currBit < bitmaskLen) {

                    if (bitmask.charAt(bitmaskLen-currBit-1) == '1') {
                        curr.add(nums[currBit]);
                    }
                    currBit++;
                }
                output.add(curr);
            }
            return output;
        }
    }
</textarea>
</code></pre>

<p>This complication can be reduced by going from 2^n to 2^(n+1) so that binary number has fixed width with a 1 as MSB.</p>

<pre><code class="language-java">
<textarea hidden>
    class Solution {

        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList();
            int n = nums.length;

            for (int i = (int) Math.pow(2, n); i < (int) Math.pow(2, n + 1); ++i) {

                String bitmask = Integer.toBinaryString(i).substring(1);
                List<Integer> curr = new ArrayList();
                for (int j = 0; j < n; ++j) {
                    if (bitmask.charAt(j) == '1') curr.add(nums[j]);
                }
                output.add(curr);
            }
            return output;
        }
    }
</textarea>
</code></pre>