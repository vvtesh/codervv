

<h3>The Maze II</h3>
<p>Approach – Dijkstra’s Shortest Path Algorithm – O(mn∗ log(mn)) </p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int shortestDistance(int[][] maze, int[] start, int[] dest) {
        int[][] distance = new int[maze.length][maze[0].length];

        for (int[] row : distance) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }

        distance[start[0]][start[1]] = 0;

        dijkstra(maze, start, distance);

        return distance[dest[0]][dest[1]] == Integer.MAX_VALUE ? -1 : distance[dest[0]][dest[1]];
    }

    public void dijkstra(int[][] maze, int[] start, int[][] distance) {
        int[][] dirs = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);

        queue.offer(new int[]{start[0], start[1], 0});

        while (!queue.isEmpty()) {
            int[] s = queue.poll();
            int r = s[0];
            int c = s[1];
            int dist = s[2];

            if (distance[r][c] < dist) {
                continue;
            }

            for (int[] dir : dirs) {
                int nextR = r + dir[0];
                int nextC = c + dir[1];
                int count = 0;

                while (nextR >= 0 && nextC >= 0 && nextR < maze.length && nextC < maze[0].length && maze[nextR][nextC] == 0) {
                    nextR += dir[0];
                    nextC += dir[1];
                    count++;
                }

                int stopR = nextR - dir[0];
                int stopC = nextC - dir[1];

                if (distance[r][c] + count < distance[stopR][stopC]) {
                    distance[stopR][stopC] = distance[r][c] + count;
                    queue.offer(new int[]{stopR, stopC, distance[stopR][stopC]});
                }
            }
        }
    }
}
</textarea>
</code></pre>
