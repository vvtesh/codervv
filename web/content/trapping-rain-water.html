
<h3>Trapping Rain Water</h3>

<p>Given n non-negative integers representing an elevation map where the width of each bar is 1,
    compute how much water it can trap after raining.</p>
<pre>
Input: height = [4,2,0,3,2,5]
Output: 9
</pre>

<p>Approach – Monotonic Stack</p>

<pre>
    Keep putting smaller ones in stack. Stack looks as follows for
    height = [0,1,0,2,1,0,1,3,2,1,2,1]:

        [0]
        []
        [1]
        [1,0]
        []
        [2]
        [2,1]
        [2,1,0]
        [2,1,1]
        []
        [3]
        [3,2]
        [3,2,1]
        [3,2,2]
        [3,2,2,1]
        Done.

    When a bigger one is found, pop the smaller one, calc area.

    Water trapped is calculated so many times:
        Calculating trapped for 1 2 3 height=1 width=1
        Calculating trapped for 4 5 6 height=1 width=1
        Calculating trapped for 4 6 7 height=0 width=2
        Calculating trapped for 3 4 7 height=1 width=3
        Calculating trapped for 8 9 10 height=1 width=1
    Numbers above are indexes, not heights.

    When a bigger one is found, but we don't have two smaller ones in stack,
        just clear the stack and continue.

    In the code, the monotonously decreasing Stack holds index (not height as shown above).

</pre>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int trap(int[] height) {
        int ans = 0, current = 0;
        Stack<Integer> st = new Stack<Integer>();
        while (current < height.length) {
            while (!st.isEmpty() && height[current] > height[st.peek()]) {
                int top = st.pop();
                if (st.isEmpty()) break;
                int currTopInStack = st.peek();
                int distance = current - currTopInStack - 1;
                int bounded_height =
                    Math.min(height[current], height[currTopInStack]) - height[top];
                ans += distance * bounded_height;
            }
            st.push(current++);
        }
        return ans;
    }
}
</textarea>
</code></pre>

<hr>

<p>Approach – Dynamic Programming</p>

<pre><code class="language-java">
<textarea hidden>
    public int trap(int[] height) {
        if (height.length == 0) return 0;
        ... //initialize ans, left_max, right_max, size
        left_max[0] = height[0];
        for (int i = 1; i < size; i++)
            left_max[i] = Math.max(height[i], left_max[i - 1]);
        right_max[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--)
            right_max[i] = Math.max(height[i], right_max[i + 1]);
 for (int i = 1; i < size - 1; i++)
            ans += Math.min(left_max[i], right_max[i]) - height[i];
        return ans;
    }

</textarea>
</code></pre>
