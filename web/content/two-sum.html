<h3>Example: Two Sum Solution (Brute Force)</h3>
<p>This code solves the classic <b>Two Sum</b> problem, which requires finding the indices of two numbers in an array that add up to a specific <code>target</code>. This solution uses the **Brute Force** approach, employing a nested loop structure. The outer loop iterates through each element, and the inner loop checks every subsequent element to see if the required complement (<code>target - nums[i]</code>) exists. While simple to implement, this method has a time complexity of $O(n^2)$.</p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
  public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
      for (int j = i + 1; j < nums.length; j++) {
        if (nums[j] == target - nums[i]) {
          return new int[] { i, j };
        }
      }
    }
    return new int[] {};
  }
}
</textarea>
</code></pre>

<hr>

<h3>Example: Two Sum Solution (Optimized HashMap)</h3>
<p>This solution also addresses the <b>Two Sum</b> problem but significantly improves performance by utilizing a <b>HashMap</b>. The approach iterates through the array only once. For each element $x$ at index $i$, it calculates the required <b>complement</b> (<code>target - x</code>). It checks if this complement already exists as a key in the map. If it does, the indices are immediately returned. If not, the current number $x$ and its index $i$ are stored in the map. This optimization reduces the time complexity to $O(n)$.</p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
  public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
      int complement = target - nums[i];
      if (map.containsKey(complement)) {
        return new int[] { map.get(complement), i };
      }
      map.put(nums[i], i);
    }
    return new int[] {};
  }
}
</textarea>
</code></pre>


<hr>

<h3>Example: Two Sum Solution (Two Pointers - Sorted Array)</h3>
<p>This code solves the <b>Two Sum</b> problem under the assumption that the input array is already sorted in ascending order. It employs the **Two Pointers** technique, initializing pointers at the start (<code>low</code>) and end (<code>high</code>) of the array. The algorithm calculates the sum of the elements at the pointers. If the sum is less than the target, the **left pointer is incremented**; if the sum is greater, the **right pointer is decremented**. This efficient approach continues until the target is found, achieving an optimal time complexity of $O(n)$.</p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
  public int[] twoSum(int[] numbers, int target) {
    int low = 0;
    int high = numbers.length - 1;
    while (low < high) {
      int sum = numbers[low] + numbers[high];
      if (sum == target) {
        return new int[] { low + 1, high + 1 };
      } else if (sum < target) {
        ++low;
      } else {
        --high;
      }
    }
    return new int[] { -1, -1 };
  }
}
</textarea>
</code></pre>

<hr>

<h3>Example: Two sum less than k</h3>
<p>Binary Search Approach</p>
<pre>
Input: nums = [34,23,1,24,75,33,54,8], k = 60
Output: 58
Explanation: We can use 34 and 24 to sum 58 which is less than 60.
</pre>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int twoSumLessThanK(int[] nums, int k) {
        int answer = -1;
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; ++i) {
            int idx = Arrays.binarySearch(nums, i + 1, nums.length, k - nums[i] - 1);
            int j = (idx >= 0 ? idx : ~idx);
            if (j == nums.length || nums[j] > k - nums[i] - 1) {
                j--;
            }
            if (j > i) {
                answer = Math.max(answer, nums[i] + nums[j]);
            }
        }
        return answer;
    }
}
</textarea>
</code></pre>

<hr>

<p>Approach - Counting Sort</p>

<pre><code class="language-java">
<textarea hidden>
int[] count = new int[1001];
        for (int num : nums) {
            count[num]++;
        }
	  â€¦
        while (lo <= hi) {
            if (lo + hi >= k || count[hi] == 0) {
                hi--;
            } else {
                if (count[lo] > (lo < hi ? 0 : 1)) {
                    answer = Math.max(answer, lo + hi);
                }
                lo++;
            }
        }
        return answer;

</textarea>
</code></pre>