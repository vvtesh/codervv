<h3>MST with Kruskal's Algorithm</h3>
<p><a href="https://leetcode.com/problems/optimize-water-distribution-in-a-village/description/">https://leetcode.com/problems/optimize-water-distribution-in-a-village/description/</a></p>
<p>This code solves the <b>Minimum Cost to Supply Water</b> problem, which is modeled as a <b>Minimum Spanning Tree (MST)</b> problem. The approach uses <b>Kruskal's Algorithm</b> combined with a <b>Union-Find</b> data structure. Virtual edges are created from a source node (0) to each house (1 to $N$), representing the cost of building a well, and these are combined with the existing pipe edges. The edges are then sorted by cost, and the Union-Find structure is used to greedily select the lowest-cost edges that do not form a cycle, cumulatively calculating the minimum total cost.</p>

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {

        ArrayList<int[]> edges = new ArrayList<>();
        for(int i=0; i<n; i++) {
            edges.add(new int[] {0, i+1, wells[i]});
        }
        for(int i=0; i<pipes.length; i++) {
            edges.add(pipes[i]);
        }
        Collections.sort(edges, (a,b) -> a[2]-b[2]);

        UnionFind unionFind = new UnionFind(n);
        int cost = 0;
        for(int[] edge: edges) {
            if (unionFind.union(edge[0], edge[1])) {
                cost += edge[2];
            }
        }
        return cost;
    }

}

class UnionFind {

    public int rank[];
    public int parent[];

    public UnionFind(int n) {
        rank = new int[n+1];
        parent = new int[n+1];

        for(int i=0; i<n+1; i++) {
            rank[i] = 0;
            parent[i] = i;
        }
    }

    public int find(int item) {
        if (item == parent[item]) {
            return item;
        }
        parent[item] = find(parent[item]);
        return parent[item];
    }

    public boolean union(int a, int b) {

        int parentOfA = find(a);
        int parentOfB = find(b);

        if (parentOfA == parentOfB) {
            return false;
        }

        if (rank[parentOfA] > rank[parentOfB]) {
            parent[parentOfB] = parentOfA;
        } else if (rank[parentOfA] < rank[parentOfB]) {
            parent[parentOfA] = parentOfB;
        } else {
            parent[parentOfB] = parentOfA;
            rank[parentOfA] += 1;
        }
        return true;
    }
}
</textarea>
</code></pre>