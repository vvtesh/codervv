<p>Minimum Spanning Tree: Kruskal's algorithm</p>

<p>How does union operation work?</p>
<img src="content/images/unionfind.png" width="300px" />

<pre><code class="language-java">
<textarea hidden>
class Solution {
    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {

        ArrayList<int[]> edges = new ArrayList<>();
        for(int i=0; i<n; i++) {
            edges.add(new int[] {0, i+1, wells[i]});
        }
        for(int i=0; i<pipes.length; i++) {
            edges.add(pipes[i]);
        }
        Collections.sort(edges, (a,b) -> a[2]-b[2]);

        UnionFind unionFind = new UnionFind(n);
        int cost = 0;
        for(int[] edge: edges) {
            if (unionFind.union(edge[0], edge[1])) {
                cost += edge[2];
            }
        }
        return cost;
    }

}

class UnionFind {

    public int rank[];
    public int parent[];

    public UnionFind(int n) {
        rank = new int[n+1];
        parent = new int[n+1];

        for(int i=0; i<n+1; i++) {
            rank[i] = 0;
            parent[i] = i;
        }
    }

    public int find(int item) {
        if (item == parent[item]) {
            return item;
        }
        parent[item] = find(parent[item]);
        return parent[item];
    }

    public boolean union(int a, int b) {

        int parentOfA = find(a);
        int parentOfB = find(b);

        if (parentOfA == parentOfB) {
            return false;
        }

        if (rank[parentOfA] > rank[parentOfB]) {
            parent[parentOfB] = parentOfA;
        } else if (rank[parentOfA] < rank[parentOfB]) {
            parent[parentOfA] = parentOfB;
        } else {
            parent[parentOfB] = parentOfA;
            rank[parentOfA] += 1;
        }
        return true;
    }
}
</textarea>
</code></pre>

<table width="100%"><tr><td align="right"><a href="https://leetcode.com/problems/optimize-water-distribution-in-a-village/description/"><img width="25px" src="content/images/leetcode.png"></a></td></tr></table>

<hr>
